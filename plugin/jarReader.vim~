let s:TmpFolder = '/tmp/tmpvimfilejar/'

function! ReadJarFile(jarpath)
    " Read a .jar file and return a list of it's contents:
    "     [(file-name, java-package, class-name, attributes-and-methods)]
    " Four-tuple above is just a regular list
    if (a:jarpath[-4:] != '.jar') && !filereadable(a:jarpath)
        return []
    endif

    let name = substitute(a:jarpath, '.*/\(.*\)\.[^\.]*$', '\1', '')
    let tmp = printf("%s/%s", s:TmpFolder, name)
    if !isdirectory(tmp)
        call mkdir(tmp, 'p')
    endif
    call system(printf('unzip %s -d %s', a:jarpath, tmp))

    let ret=[]
    let pkg=''
    let class=''
    let attrs=[]
    for path in split(system(printf("find %s -iname '*.class'", tmp)))
        let pkg = substitute(path, '\/[^\/]*$', '', '')
        let class = substitute(path, '.*\/\([^\/]*\).class$', '\1', '')
        let class = substitute(path, '\$', '.', 'g')
        if (class =~ '\.\d*$')
            continue " Skip anonymous classes
        endif
        let attrs=[]
        for line in split(system(printf('strings %s | grep -v "[^a-zA-Z0-9_ ]" | sed "s/ //g"', path)))
            call insert(attrs, line)
        endfor
        call reverse(attrs)
        call insert(ret, [a:jarpath, pkg, class, attrs])
    endfor
    return ret
endfunction

function! ReadJavaFilesRecursively(path)
    " TODO Read recursively all .java files from a:path and add them into
    " index
endfunction

function! ReadIndexFile(path)
    " TODO Read recursively all .java files from a:path and add them into
    " index
endfunction

" === Index ===================================================================

" [(class-name, package, attrs)]
let s:Index = []
let s:IndexByClassNames = {}

function! AddInfoToIndex(filepath, pkg, fullClass, attrs)
    let info = [a:filepath, a:pkg, a:fullClass, a:attrs]
    call insert(s:Index, info)

    let class = fullClass
    while (class =~ '\.' )
        " Class name is inner-class
        let class = substitute(class, '^.*\.', '', '')
    endif
endfunction
